<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spotify å³æ™‚æ’­æ”¾å™¨</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            box-sizing: border-box;
        }
        
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap');
        
        * {
            font-family: 'Inter', sans-serif;
        }
        
        .glow {
            box-shadow: 0 0 20px rgba(29, 185, 84, 0.3);
        }
        
        .time-glow {
            text-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
        }
        
        .wave {
            display: flex;
            align-items: end;
            justify-content: center;
            height: 24px;
            gap: 1px;
        }
        
        .wave-bar {
            width: 2px;
            background: linear-gradient(to top, #1db954, #1ed760);
            border-radius: 1px;
            transition: all 0.3s ease;
        }
        
        .playing .wave-bar {
            animation: wave 1.5s ease-in-out infinite;
        }
        
        .wave-bar:nth-child(1) { height: 8px; animation-delay: 0s; }
        .wave-bar:nth-child(2) { height: 16px; animation-delay: 0.1s; }
        .wave-bar:nth-child(3) { height: 12px; animation-delay: 0.2s; }
        .wave-bar:nth-child(4) { height: 20px; animation-delay: 0.3s; }
        .wave-bar:nth-child(5) { height: 6px; animation-delay: 0.4s; }
        .wave-bar:nth-child(6) { height: 14px; animation-delay: 0.5s; }
        .wave-bar:nth-child(7) { height: 18px; animation-delay: 0.6s; }
        .wave-bar:nth-child(8) { height: 10px; animation-delay: 0.7s; }
        
        @keyframes wave {
            0%, 100% { transform: scaleY(0.3); opacity: 0.6; }
            50% { transform: scaleY(1); opacity: 1; }
        }
        
        .progress-track {
            background: linear-gradient(90deg, #1db954 var(--progress, 0%), #1f2937 var(--progress, 0%));
        }
        
        .control-btn {
            transition: all 0.2s ease;
            backdrop-filter: blur(10px);
        }
        
        .control-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(29, 185, 84, 0.3);
        }
        
        .control-btn:active {
            transform: scale(0.95);
        }
        
        .album-art {
            width: 120px;
            height: 120px;
            border-radius: 12px;
            background: linear-gradient(135deg, #1db954 0%, #1ed760 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 20px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        .album-art img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .rotating {
            animation: rotate 10s linear infinite;
        }
        
        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .spotify-green {
            background-color: #1db954;
        }
        
        .spotify-green:hover {
            background-color: #1ed760;
        }
        
        .login-container {
            text-align: center;
        }
        
        .hidden {
            display: none;
        }
        
        .volume-slider {
            -webkit-appearance: none;
            appearance: none;
            height: 4px;
            background: #374151;
            border-radius: 2px;
            outline: none;
        }
        
        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #1db954;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .volume-slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #1db954;
            border-radius: 50%;
            cursor: pointer;
            border: none;
        }
        
        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(29, 185, 84, 0.9);
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            backdrop-filter: blur(10px);
            transform: translateX(400px);
            transition: transform 0.3s ease;
            z-index: 1000;
        }
        
        .notification.show {
            transform: translateX(0);
        }
    </style>
</head>
<body class="bg-black min-h-screen flex items-center justify-center p-4">
    <!-- é€šçŸ¥ -->
    <div class="notification" id="notification">
        <span id="notificationText">é€šçŸ¥è¨Šæ¯</span>
    </div>
    
    <div class="bg-gray-900/80 backdrop-blur-xl rounded-2xl p-8 shadow-2xl border border-gray-700/50 max-w-sm w-full glow">
        
        <!-- æ™‚é–“é¡¯ç¤º -->
        <div class="text-center mb-6">
            <div class="text-3xl font-light text-white time-glow mb-1" id="currentTime">
                --:--:--
            </div>
            <div class="text-blue-400 text-xs font-medium tracking-wide" id="timezone">
                è¼‰å…¥ä¸­...
            </div>
            <div class="text-gray-400 text-xs mt-1" id="date">
                --
            </div>
        </div>
        
        <!-- ç™»å…¥å€åŸŸ -->
        <div class="login-container" id="loginContainer">
            <div class="mb-6">
                <svg width="48" height="48" viewBox="0 0 24 24" fill="#1db954" class="mx-auto mb-4">
                    <path d="M12 0C5.4 0 0 5.4 0 12s5.4 12 12 12 12-5.4 12-12S18.66 0 12 0zm5.521 17.34c-.24.359-.66.48-1.021.24-2.82-1.74-6.36-2.101-10.561-1.141-.418.122-.779-.179-.899-.539-.12-.421.18-.78.54-.9 4.56-1.021 8.52-.6 11.64 1.32.42.18.479.659.301 1.02zm1.44-3.3c-.301.42-.841.6-1.262.3-3.239-1.98-8.159-2.58-11.939-1.38-.479.12-1.02-.12-1.14-.6-.12-.48.12-1.021.6-1.141C9.6 9.9 15 10.561 18.72 12.84c.361.181.54.78.241 1.2zm.12-3.36C15.24 8.4 8.82 8.16 5.16 9.301c-.6.179-1.2-.181-1.38-.721-.18-.601.18-1.2.72-1.381 4.26-1.26 11.28-1.02 15.721 1.621.539.3.719 1.02.42 1.56-.299.421-1.02.599-1.559.3z"/>
                </svg>
                <h2 class="text-white text-xl font-semibold mb-2">é€£æ¥ Spotify</h2>
                <p class="text-gray-400 text-sm mb-6">ç™»å…¥ä½ çš„ Spotify å¸³æˆ¶ä¾†é¡¯ç¤ºæ­£åœ¨æ’­æ”¾çš„éŸ³æ¨‚</p>
                <button class="spotify-green text-white px-6 py-3 rounded-full font-medium hover:scale-105 transition-all" id="loginBtn">
                    ğŸµ é€£æ¥ Spotify
                </button>
                <div class="mt-4 text-xs text-gray-500">
                    <p>éœ€è¦ Spotify Premium å¸³æˆ¶æ‰èƒ½ä½¿ç”¨æ’­æ”¾æ§åˆ¶åŠŸèƒ½</p>
                </div>
            </div>
        </div>
        
        <!-- æ’­æ”¾å™¨å€åŸŸ -->
        <div class="hidden" id="playerContainer">
            <!-- å°ˆè¼¯å°é¢ -->
            <div class="album-art" id="albumArt">
                <svg width="48" height="48" viewBox="0 0 24 24" fill="white" opacity="0.7">
                    <path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/>
                </svg>
            </div>
            
            <!-- éŸ³æ¨‚è³‡è¨Š -->
            <div class="text-center mb-6">
                <div class="text-white text-lg font-medium mb-1" id="songTitle">
                    æœªæ’­æ”¾éŸ³æ¨‚
                </div>
                <div class="text-gray-400 text-sm mb-4" id="artist">
                    --
                </div>
                
                <!-- éŸ³æ³¢è¦–è¦ºåŒ– -->
                <div class="wave mb-6" id="waveform">
                    <div class="wave-bar"></div>
                    <div class="wave-bar"></div>
                    <div class="wave-bar"></div>
                    <div class="wave-bar"></div>
                    <div class="wave-bar"></div>
                    <div class="wave-bar"></div>
                    <div class="wave-bar"></div>
                    <div class="wave-bar"></div>
                </div>
            </div>
            
            <!-- é€²åº¦æ¢ -->
            <div class="mb-6">
                <div class="flex justify-between text-xs text-gray-400 mb-2">
                    <span id="currentTimeTrack">0:00</span>
                    <span id="totalTime">0:00</span>
                </div>
                <div class="h-1 bg-gray-700 rounded-full overflow-hidden cursor-pointer" id="progressContainer">
                    <div class="progress-track h-full rounded-full transition-all duration-300" id="progressBar" style="--progress: 0%"></div>
                </div>
            </div>
            
            <!-- æ§åˆ¶æŒ‰éˆ• -->
            <div class="flex justify-center items-center gap-6 mb-6">
                <button class="control-btn bg-gray-800/50 hover:bg-gray-700/50 text-gray-300 w-10 h-10 rounded-full flex items-center justify-center" id="prevBtn">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"/>
                    </svg>
                </button>
                
                <button class="control-btn spotify-green text-white w-14 h-14 rounded-full flex items-center justify-center" id="playBtn">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" id="playIcon">
                        <path d="M8 5v14l11-7z"/>
                    </svg>
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor" id="pauseIcon" style="display: none;">
                        <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/>
                    </svg>
                </button>
                
                <button class="control-btn bg-gray-800/50 hover:bg-gray-700/50 text-gray-300 w-10 h-10 rounded-full flex items-center justify-center" id="nextBtn">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M16 18h2V6h-2v12zM6 18l8.5-6L6 6v12z"/>
                    </svg>
                </button>
            </div>
            
            <!-- éŸ³é‡æ§åˆ¶ -->
            <div class="mb-6">
                <div class="flex items-center gap-3">
                    <svg width="16" height="16" viewBox="0 0 24 24" fill="#9CA3AF">
                        <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                    </svg>
                    <input type="range" min="0" max="100" value="50" class="volume-slider flex-1" id="volumeSlider">
                    <span class="text-gray-400 text-xs w-8" id="volumeText">50%</span>
                </div>
            </div>
            
            <!-- éš¨æ©Ÿæ’­æ”¾å’Œé‡è¤‡æ’­æ”¾ -->
            <div class="flex justify-center items-center gap-8 mb-6">
                <button class="control-btn bg-gray-800/50 hover:bg-gray-700/50 text-gray-400 w-8 h-8 rounded-full flex items-center justify-center" id="shuffleBtn" title="éš¨æ©Ÿæ’­æ”¾">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M10.59 9.17L5.41 4 4 5.41l5.17 5.17 1.42-1.41zM14.5 4l2.04 2.04L4 18.59 5.41 20 17.96 7.46 20 9.5V4h-5.5zm.33 9.41l-1.41 1.41 3.13 3.13L14.5 20H20v-5.5l-2.04 2.04-3.13-3.13z"/>
                    </svg>
                </button>
                
                <button class="control-btn bg-gray-800/50 hover:bg-gray-700/50 text-gray-400 w-8 h-8 rounded-full flex items-center justify-center" id="repeatBtn" title="é‡è¤‡æ’­æ”¾">
                    <svg width="14" height="14" viewBox="0 0 24 24" fill="currentColor">
                        <path d="M7 7h10v3l4-4-4-4v3H5v6h2V7zm10 10H7v-3l-4 4 4 4v-3h12v-6h-2v4z"/>
                    </svg>
                </button>
            </div>
            
            <!-- ç‹€æ…‹é¡¯ç¤º -->
            <div class="text-center">
                <div class="text-green-400 text-xs mb-2" id="statusText">ğŸµ å·²é€£æ¥ Spotify</div>
                <button class="text-gray-400 text-xs hover:text-white transition-colors" id="logoutBtn">
                    ç™»å‡º
                </button>
            </div>
        </div>
    </div>

    <script>
        // Spotify API é…ç½®
        const CLIENT_ID = '1ddef18bca4a4b7daa73d2aca2f2018f';
        const CLIENT_SECRET = 'de45cfcb2ccf40b89e07dadb5c90704e';
        const REDIRECT_URI = 'https://i-like-dev.github.io/Play/callback.html';
        const SCOPES = 'user-read-currently-playing user-read-playback-state user-modify-playback-state';
        
        let accessToken = localStorage.getItem('spotify_access_token');
        let refreshToken = localStorage.getItem('spotify_refresh_token');
        let currentTrack = null;
        let updateInterval = null;
        let isUpdatingProgress = false;
        let volumeTimeout = null;
        
        // DOM å…ƒç´ 
        const elements = {
            currentTime: document.getElementById('currentTime'),
            timezone: document.getElementById('timezone'),
            date: document.getElementById('date'),
            loginContainer: document.getElementById('loginContainer'),
            playerContainer: document.getElementById('playerContainer'),
            loginBtn: document.getElementById('loginBtn'),
            logoutBtn: document.getElementById('logoutBtn'),
            songTitle: document.getElementById('songTitle'),
            artist: document.getElementById('artist'),
            albumArt: document.getElementById('albumArt'),
            waveform: document.getElementById('waveform'),
            currentTimeTrack: document.getElementById('currentTimeTrack'),
            totalTime: document.getElementById('totalTime'),
            progressBar: document.getElementById('progressBar'),
            progressContainer: document.getElementById('progressContainer'),
            playBtn: document.getElementById('playBtn'),
            playIcon: document.getElementById('playIcon'),
            pauseIcon: document.getElementById('pauseIcon'),
            prevBtn: document.getElementById('prevBtn'),
            nextBtn: document.getElementById('nextBtn'),
            statusText: document.getElementById('statusText'),
            volumeSlider: document.getElementById('volumeSlider'),
            volumeText: document.getElementById('volumeText'),
            shuffleBtn: document.getElementById('shuffleBtn'),
            repeatBtn: document.getElementById('repeatBtn'),
            notification: document.getElementById('notification'),
            notificationText: document.getElementById('notificationText')
        };
        
        // é¡¯ç¤ºé€šçŸ¥
        function showNotification(message) {
            elements.notificationText.textContent = message;
            elements.notification.classList.add('show');
            setTimeout(() => {
                elements.notification.classList.remove('show');
            }, 3000);
        }
        
        // æ™‚é–“æ›´æ–°å‡½æ•¸
        function updateTime() {
            const now = new Date();
            
            const timeString = now.toLocaleTimeString('zh-TW', {
                hour12: false,
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
            
            const dateString = now.toLocaleDateString('zh-TW', {
                month: 'short',
                day: 'numeric',
                weekday: 'short'
            });
            
            const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
            const offset = now.getTimezoneOffset();
            const offsetHours = Math.abs(Math.floor(offset / 60));
            const offsetMinutes = Math.abs(offset % 60);
            const offsetSign = offset <= 0 ? '+' : '-';
            const offsetString = `UTC${offsetSign}${offsetHours.toString().padStart(2, '0')}:${offsetMinutes.toString().padStart(2, '0')}`;
            
            elements.currentTime.textContent = timeString;
            elements.timezone.textContent = `${timezone.split('/').pop().replace('_', ' ')} ${offsetString}`;
            elements.date.textContent = dateString;
        }
        
        // æ ¼å¼åŒ–æ™‚é–“
        function formatTime(ms) {
            const seconds = Math.floor(ms / 1000);
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        // Spotify ç™»å…¥
        function loginToSpotify() {
            const authUrl = `https://accounts.spotify.com/authorize?` +
                `client_id=${CLIENT_ID}&` +
                `response_type=code&` +
                `redirect_uri=${encodeURIComponent(REDIRECT_URI)}&` +
                `scope=${encodeURIComponent(SCOPES)}`;
            
            showNotification('æ­£åœ¨é–‹å•Ÿ Spotify æˆæ¬Šé é¢...');
            window.open(authUrl, '_blank', 'noopener,noreferrer');
        }
        
        // ç›£è½ä¾†è‡ªå›èª¿é é¢çš„æ¶ˆæ¯
        window.addEventListener('message', function(event) {
            if (event.data.type === 'spotify_auth' && event.data.code) {
                showNotification('æ­£åœ¨é€£æ¥ Spotify...');
                getAccessToken(event.data.code);
            } else if (event.data.type === 'spotify_error') {
                showNotification('âŒ æˆæ¬Šå¤±æ•—ï¼Œè«‹é‡è©¦');
                elements.statusText.textContent = 'âŒ æˆæ¬Šå¤±æ•—ï¼Œè«‹é‡è©¦';
            }
        });
        
        // ç²å– Access Token
        async function getAccessToken(code) {
            try {
                const response = await fetch('https://accounts.spotify.com/api/token', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'Authorization': 'Basic ' + btoa(CLIENT_ID + ':' + CLIENT_SECRET)
                    },
                    body: new URLSearchParams({
                        grant_type: 'authorization_code',
                        code: code,
                        redirect_uri: REDIRECT_URI,
                    }),
                });
                
                const data = await response.json();
                
                if (data.access_token) {
                    accessToken = data.access_token;
                    refreshToken = data.refresh_token;
                    
                    // å„²å­˜åˆ° localStorage
                    localStorage.setItem('spotify_access_token', accessToken);
                    if (refreshToken) {
                        localStorage.setItem('spotify_refresh_token', refreshToken);
                    }
                    
                    showNotification('âœ… æˆåŠŸé€£æ¥ Spotifyï¼');
                    showPlayer();
                    startPolling();
                } else {
                    console.error('Failed to get access token:', data);
                    showNotification('âŒ ç™»å…¥å¤±æ•—ï¼Œè«‹é‡è©¦');
                    elements.statusText.textContent = 'âŒ ç™»å…¥å¤±æ•—ï¼Œè«‹é‡è©¦';
                }
            } catch (error) {
                console.error('Error getting access token:', error);
                showNotification('âŒ ç¶²è·¯éŒ¯èª¤ï¼Œè«‹é‡è©¦');
                elements.statusText.textContent = 'âŒ ç¶²è·¯éŒ¯èª¤ï¼Œè«‹é‡è©¦';
            }
        }
        
        // åˆ·æ–° Access Token
        async function refreshAccessToken() {
            if (!refreshToken) return false;
            
            try {
                const response = await fetch('https://accounts.spotify.com/api/token', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                        'Authorization': 'Basic ' + btoa(CLIENT_ID + ':' + CLIENT_SECRET)
                    },
                    body: new URLSearchParams({
                        grant_type: 'refresh_token',
                        refresh_token: refreshToken,
                    }),
                });
                
                const data = await response.json();
                
                if (data.access_token) {
                    accessToken = data.access_token;
                    localStorage.setItem('spotify_access_token', accessToken);
                    return true;
                }
            } catch (error) {
                console.error('Error refreshing token:', error);
            }
            
            return false;
        }
        
        // é¡¯ç¤ºæ’­æ”¾å™¨
        function showPlayer() {
            elements.loginContainer.classList.add('hidden');
            elements.playerContainer.classList.remove('hidden');
            elements.statusText.innerHTML = 'ğŸµ å·²é€£æ¥ Spotify';
        }
        
        // ç²å–ç•¶å‰æ’­æ”¾ç‹€æ…‹
        async function getCurrentlyPlaying() {
            if (!accessToken) return null;
            
            try {
                const response = await fetch('https://api.spotify.com/v1/me/player/currently-playing', {
                    headers: {
                        'Authorization': `Bearer ${accessToken}`,
                    },
                });
                
                if (response.status === 401) {
                    // Token éæœŸï¼Œå˜—è©¦åˆ·æ–°
                    const refreshed = await refreshAccessToken();
                    if (refreshed) {
                        return getCurrentlyPlaying();
                    } else {
                        logout();
                        return null;
                    }
                }
                
                if (response.status === 204) {
                    // æ²’æœ‰æ­£åœ¨æ’­æ”¾çš„éŸ³æ¨‚
                    return null;
                }
                
                const data = await response.json();
                return data;
            } catch (error) {
                console.error('Error getting currently playing:', error);
                return null;
            }
        }
        
        // æ’­æ”¾æ§åˆ¶
        async function playPause() {
            if (!accessToken) return;
            
            try {
                const currentState = await getCurrentlyPlaying();
                const isPlaying = currentState && currentState.is_playing;
                
                const endpoint = isPlaying ? 'pause' : 'play';
                const response = await fetch(`https://api.spotify.com/v1/me/player/${endpoint}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${accessToken}`,
                    },
                });
                
                if (response.status === 401) {
                    const refreshed = await refreshAccessToken();
                    if (refreshed) {
                        return playPause();
                    }
                } else if (response.status === 403) {
                    showNotification('éœ€è¦ Spotify Premium æ‰èƒ½æ§åˆ¶æ’­æ”¾');
                } else if (response.status === 404) {
                    showNotification('æ‰¾ä¸åˆ°å¯ç”¨çš„æ’­æ”¾è¨­å‚™');
                } else {
                    showNotification(isPlaying ? 'â¸ï¸ å·²æš«åœ' : 'â–¶ï¸ é–‹å§‹æ’­æ”¾');
                }
                
                // ç«‹å³æ›´æ–°ç‹€æ…‹
                setTimeout(updateCurrentTrack, 500);
            } catch (error) {
                console.error('Error controlling playback:', error);
                showNotification('æ’­æ”¾æ§åˆ¶å¤±æ•—');
            }
        }
        
        // ä¸Šä¸€é¦–
        async function previousTrack() {
            if (!accessToken) return;
            
            try {
                const response = await fetch('https://api.spotify.com/v1/me/player/previous', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${accessToken}`,
                    },
                });
                
                if (response.status === 401) {
                    const refreshed = await refreshAccessToken();
                    if (refreshed) {
                        return previousTrack();
                    }
                } else if (response.status === 403) {
                    showNotification('éœ€è¦ Spotify Premium æ‰èƒ½åˆ‡æ›æ­Œæ›²');
                } else if (response.status === 404) {
                    showNotification('æ‰¾ä¸åˆ°å¯ç”¨çš„æ’­æ”¾è¨­å‚™');
                } else {
                    showNotification('â®ï¸ ä¸Šä¸€é¦–');
                }
                
                setTimeout(updateCurrentTrack, 500);
            } catch (error) {
                console.error('Error skipping to previous:', error);
                showNotification('åˆ‡æ›æ­Œæ›²å¤±æ•—');
            }
        }
        
        // ä¸‹ä¸€é¦–
        async function nextTrack() {
            if (!accessToken) return;
            
            try {
                const response = await fetch('https://api.spotify.com/v1/me/player/next', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${accessToken}`,
                    },
                });
                
                if (response.status === 401) {
                    const refreshed = await refreshAccessToken();
                    if (refreshed) {
                        return nextTrack();
                    }
                } else if (response.status === 403) {
                    showNotification('éœ€è¦ Spotify Premium æ‰èƒ½åˆ‡æ›æ­Œæ›²');
                } else if (response.status === 404) {
                    showNotification('æ‰¾ä¸åˆ°å¯ç”¨çš„æ’­æ”¾è¨­å‚™');
                } else {
                    showNotification('â­ï¸ ä¸‹ä¸€é¦–');
                }
                
                setTimeout(updateCurrentTrack, 500);
            } catch (error) {
                console.error('Error skipping to next:', error);
                showNotification('åˆ‡æ›æ­Œæ›²å¤±æ•—');
            }
        }
        
        // è¨­å®šéŸ³é‡
        async function setVolume(volume) {
            if (!accessToken) return;
            
            try {
                const response = await fetch(`https://api.spotify.com/v1/me/player/volume?volume_percent=${volume}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${accessToken}`,
                    },
                });
                
                if (response.status === 401) {
                    const refreshed = await refreshAccessToken();
                    if (refreshed) {
                        return setVolume(volume);
                    }
                } else if (response.status === 403) {
                    showNotification('éœ€è¦ Spotify Premium æ‰èƒ½èª¿æ•´éŸ³é‡');
                } else if (response.status === 404) {
                    showNotification('æ‰¾ä¸åˆ°å¯ç”¨çš„æ’­æ”¾è¨­å‚™');
                }
            } catch (error) {
                console.error('Error setting volume:', error);
            }
        }
        
        // åˆ‡æ›éš¨æ©Ÿæ’­æ”¾
        async function toggleShuffle() {
            if (!accessToken) return;
            
            try {
                const currentState = await getCurrentlyPlaying();
                if (!currentState) return;
                
                const shuffleState = !currentState.shuffle_state;
                const response = await fetch(`https://api.spotify.com/v1/me/player/shuffle?state=${shuffleState}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${accessToken}`,
                    },
                });
                
                if (response.status === 401) {
                    const refreshed = await refreshAccessToken();
                    if (refreshed) {
                        return toggleShuffle();
                    }
                } else if (response.status === 403) {
                    showNotification('éœ€è¦ Spotify Premium æ‰èƒ½åˆ‡æ›éš¨æ©Ÿæ’­æ”¾');
                } else if (response.status === 404) {
                    showNotification('æ‰¾ä¸åˆ°å¯ç”¨çš„æ’­æ”¾è¨­å‚™');
                } else {
                    showNotification(shuffleState ? 'ğŸ”€ éš¨æ©Ÿæ’­æ”¾å·²é–‹å•Ÿ' : 'ğŸ”€ éš¨æ©Ÿæ’­æ”¾å·²é—œé–‰');
                    
                    // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
                    if (shuffleState) {
                        elements.shuffleBtn.classList.add('text-green-400');
                        elements.shuffleBtn.classList.remove('text-gray-400');
                    } else {
                        elements.shuffleBtn.classList.add('text-gray-400');
                        elements.shuffleBtn.classList.remove('text-green-400');
                    }
                }
            } catch (error) {
                console.error('Error toggling shuffle:', error);
                showNotification('åˆ‡æ›éš¨æ©Ÿæ’­æ”¾å¤±æ•—');
            }
        }
        
        // åˆ‡æ›é‡è¤‡æ’­æ”¾
        async function toggleRepeat() {
            if (!accessToken) return;
            
            try {
                const currentState = await getCurrentlyPlaying();
                if (!currentState) return;
                
                let repeatState = 'off';
                if (currentState.repeat_state === 'off') {
                    repeatState = 'context';
                } else if (currentState.repeat_state === 'context') {
                    repeatState = 'track';
                }
                
                const response = await fetch(`https://api.spotify.com/v1/me/player/repeat?state=${repeatState}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${accessToken}`,
                    },
                });
                
                if (response.status === 401) {
                    const refreshed = await refreshAccessToken();
                    if (refreshed) {
                        return toggleRepeat();
                    }
                } else if (response.status === 403) {
                    showNotification('éœ€è¦ Spotify Premium æ‰èƒ½åˆ‡æ›é‡è¤‡æ’­æ”¾');
                } else if (response.status === 404) {
                    showNotification('æ‰¾ä¸åˆ°å¯ç”¨çš„æ’­æ”¾è¨­å‚™');
                } else {
                    const messages = {
                        'off': 'ğŸ” é‡è¤‡æ’­æ”¾å·²é—œé–‰',
                        'context': 'ğŸ” é‡è¤‡æ’­æ”¾æ¸…å–®',
                        'track': 'ğŸ”‚ é‡è¤‡å–®æ›²'
                    };
                    showNotification(messages[repeatState]);
                    
                    // æ›´æ–°æŒ‰éˆ•ç‹€æ…‹
                    if (repeatState !== 'off') {
                        elements.repeatBtn.classList.add('text-green-400');
                        elements.repeatBtn.classList.remove('text-gray-400');
                    } else {
                        elements.repeatBtn.classList.add('text-gray-400');
                        elements.repeatBtn.classList.remove('text-green-400');
                    }
                }
            } catch (error) {
                console.error('Error toggling repeat:', error);
                showNotification('åˆ‡æ›é‡è¤‡æ’­æ”¾å¤±æ•—');
            }
        }
        
        // æ›´æ–°ç•¶å‰éŸ³è»Œ
        async function updateCurrentTrack() {
            if (isUpdatingProgress) return;
            
            const data = await getCurrentlyPlaying();
            
            if (data && data.item) {
                currentTrack = data;
                updatePlayerDisplay(data);
            } else {
                // æ²’æœ‰æ­£åœ¨æ’­æ”¾çš„éŸ³æ¨‚
                elements.songTitle.textContent = 'æœªæ’­æ”¾éŸ³æ¨‚';
                elements.artist.textContent = 'è«‹åœ¨ Spotify ä¸­æ’­æ”¾éŸ³æ¨‚';
                elements.currentTimeTrack.textContent = '0:00';
                elements.totalTime.textContent = '0:00';
                elements.progressBar.style.setProperty('--progress', '0%');
                elements.waveform.classList.remove('playing');
                elements.albumArt.classList.remove('rotating');
                elements.albumArt.innerHTML = `
                    <svg width="48" height="48" viewBox="0 0 24 24" fill="white" opacity="0.7">
                        <path d="M12 3v10.55c-.59-.34-1.27-.55-2-.55-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4V7h4V3h-6z"/>
                    </svg>
                `;
                elements.playIcon.style.display = 'block';
                elements.pauseIcon.style.display = 'none';
            }
        }
        
        // é–‹å§‹è¼ªè©¢
        function startPolling() {
            updateCurrentTrack(); // ç«‹å³æ›´æ–°ä¸€æ¬¡
            updateInterval = setInterval(updateCurrentTrack, 3000); // æ¯3ç§’æ›´æ–°ä¸€æ¬¡
        }
        
        // åœæ­¢è¼ªè©¢
        function stopPolling() {
            if (updateInterval) {
                clearInterval(updateInterval);
                updateInterval = null;
            }
        }
        
        // æ›´æ–°æ’­æ”¾å™¨é¡¯ç¤º
        function updatePlayerDisplay(data) {
            if (!data || !data.item) return;
            
            const track = data.item;
            
            elements.songTitle.textContent = track.name;
            elements.artist.textContent = track.artists.map(a => a.name).join(', ');
            elements.totalTime.textContent = formatTime(track.duration_ms);
            
            // æ›´æ–°å°ˆè¼¯å°é¢
            if (track.album && track.album.images && track.album.images.length > 0) {
                elements.albumArt.innerHTML = `<img src="${track.album.images[0].url}" alt="å°ˆè¼¯å°é¢" onerror="this.style.display='none';">`;
            }
            
            // æ›´æ–°æ’­æ”¾ç‹€æ…‹
            if (data.is_playing) {
                elements.playIcon.style.display = 'none';
                elements.pauseIcon.style.display = 'block';
                elements.waveform.classList.add('playing');
                elements.albumArt.classList.add('rotating');
            } else {
                elements.playIcon.style.display = 'block';
                elements.pauseIcon.style.display = 'none';
                elements.waveform.classList.remove('playing');
                elements.albumArt.classList.remove('rotating');
            }
            
            // æ›´æ–°é€²åº¦
            if (data.progress_ms && track.duration_ms) {
                const progress = (data.progress_ms / track.duration_ms) * 100;
                elements.progressBar.style.setProperty('--progress', `${progress}%`);
                elements.currentTimeTrack.textContent = formatTime(data.progress_ms);
            }
            
            // æ›´æ–°éš¨æ©Ÿæ’­æ”¾å’Œé‡è¤‡æ’­æ”¾ç‹€æ…‹
            if (data.shuffle_state) {
                elements.shuffleBtn.classList.add('text-green-400');
                elements.shuffleBtn.classList.remove('text-gray-400');
            } else {
                elements.shuffleBtn.classList.add('text-gray-400');
                elements.shuffleBtn.classList.remove('text-green-400');
            }
            
            if (data.repeat_state !== 'off') {
                elements.repeatBtn.classList.add('text-green-400');
                elements.repeatBtn.classList.remove('text-gray-400');
            } else {
                elements.repeatBtn.classList.add('text-gray-400');
                elements.repeatBtn.classList.remove('text-green-400');
            }
        }
        
        // ç™»å‡º
        function logout() {
            accessToken = null;
            refreshToken = null;
            localStorage.removeItem('spotify_access_token');
            localStorage.removeItem('spotify_refresh_token');
            stopPolling();
            elements.playerContainer.classList.add('hidden');
            elements.loginContainer.classList.remove('hidden');
            showNotification('å·²ç™»å‡º Spotify');
        }
        
        // é€²åº¦æ¢é»æ“Šäº‹ä»¶
        elements.progressContainer.addEventListener('click', async function(e) {
            if (!currentTrack || !currentTrack.item) return;
            
            const rect = this.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const width = rect.width;
            const percentage = clickX / width;
            const newPosition = Math.floor(currentTrack.item.duration_ms * percentage);
            
            isUpdatingProgress = true;
            
            try {
                const response = await fetch(`https://api.spotify.com/v1/me/player/seek?position_ms=${newPosition}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${accessToken}`,
                    },
                });
                
                if (response.status === 401) {
                    const refreshed = await refreshAccessToken();
                    if (refreshed) {
                        // é‡è©¦
                        await fetch(`https://api.spotify.com/v1/me/player/seek?position_ms=${newPosition}`, {
                            method: 'PUT',
                            headers: {
                                'Authorization': `Bearer ${accessToken}`,
                            },
                        });
                    }
                } else if (response.status === 403) {
                    showNotification('éœ€è¦ Spotify Premium æ‰èƒ½èª¿æ•´æ’­æ”¾ä½ç½®');
                } else if (response.status === 404) {
                    showNotification('æ‰¾ä¸åˆ°å¯ç”¨çš„æ’­æ”¾è¨­å‚™');
                } else {
                    // ç«‹å³æ›´æ–°é€²åº¦é¡¯ç¤º
                    const progress = percentage * 100;
                    elements.progressBar.style.setProperty('--progress', `${progress}%`);
                    elements.currentTimeTrack.textContent = formatTime(newPosition);
                }
                
                setTimeout(() => {
                    isUpdatingProgress = false;
                    updateCurrentTrack();
                }, 1000);
            } catch (error) {
                console.error('Error seeking:', error);
                showNotification('èª¿æ•´æ’­æ”¾ä½ç½®å¤±æ•—');
                isUpdatingProgress = false;
            }
        });
        
        // éŸ³é‡æ§åˆ¶äº‹ä»¶
        elements.volumeSlider.addEventListener('input', function() {
            const volume = this.value;
            elements.volumeText.textContent = volume + '%';
            
            // é˜²æŠ–è™•ç†ï¼Œé¿å…é »ç¹èª¿ç”¨ API
            if (volumeTimeout) {
                clearTimeout(volumeTimeout);
            }
            volumeTimeout = setTimeout(() => {
                setVolume(volume);
            }, 300);
        });
        
        // æ§åˆ¶æŒ‰éˆ•äº‹ä»¶
        elements.playBtn.addEventListener('click', playPause);
        elements.prevBtn.addEventListener('click', previousTrack);
        elements.nextBtn.addEventListener('click', nextTrack);
        elements.shuffleBtn.addEventListener('click', toggleShuffle);
        elements.repeatBtn.addEventListener('click', toggleRepeat);
        
        // ç™»å…¥/ç™»å‡ºæŒ‰éˆ•
        elements.loginBtn.addEventListener('click', loginToSpotify);
        elements.logoutBtn.addEventListener('click', logout);
        
        // éµç›¤å¿«æ·éµ
        document.addEventListener('keydown', function(e) {
            if (!accessToken) return;
            
            switch(e.code) {
                case 'Space':
                    e.preventDefault();
                    playPause();
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    previousTrack();
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    nextTrack();
                    break;
            }
        });
        
        // åˆå§‹åŒ–
        updateTime();
        setInterval(updateTime, 1000);
        
        // æª¢æŸ¥æ˜¯å¦å·²ç¶“æœ‰ access token
        if (accessToken) {
            showPlayer();
            startPolling();
        }
        
        // é é¢å¯è¦‹æ€§è®ŠåŒ–æ™‚çš„è™•ç†
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                // é é¢éš±è—æ™‚æ¸›å°‘æ›´æ–°é »ç‡
                if (updateInterval) {
                    clearInterval(updateInterval);
                    updateInterval = setInterval(updateCurrentTrack, 10000); // 10ç§’æ›´æ–°ä¸€æ¬¡
                }
            } else {
                // é é¢é¡¯ç¤ºæ™‚æ¢å¾©æ­£å¸¸æ›´æ–°é »ç‡
                if (accessToken && updateInterval) {
                    clearInterval(updateInterval);
                    updateInterval = setInterval(updateCurrentTrack, 3000); // 3ç§’æ›´æ–°ä¸€æ¬¡
                    updateCurrentTrack(); // ç«‹å³æ›´æ–°ä¸€æ¬¡
                }
            }
        });
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'98508feef6571a2d',t:'MTc1ODg2NjY0OS4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
